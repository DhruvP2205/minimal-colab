<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Collaborative Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #4a5568;
            font-size: 2em;
        }

        .disconnect-btn {
            background: #e53e3e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            display: none;
        }

        .disconnect-btn:hover {
            background: #c53030;
        }

        .mode-selection {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .mode-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.6);
        }

        .mode-btn.active {
            background: linear-gradient(45deg, #fa709a 0%, #fee140 100%);
            box-shadow: 0 4px 15px rgba(250, 112, 154, 0.4);
        }

        .connection-panel {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.95) 100%);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .connection-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .connection-title {
            font-size: 1.8em;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .connection-subtitle {
            color: #64748b;
            font-size: 0.95em;
        }

        .role-selection {
            display: flex;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 8px;
            margin-bottom: 30px;
            border: 2px solid rgba(79, 172, 254, 0.1);
        }

        .role-btn {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            background: transparent;
            color: #64748b;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .role-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }

        .role-btn:hover::before {
            left: 100%;
        }

        .role-btn.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(79, 172, 254, 0.3);
        }

        .token-section {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 250, 252, 0.9) 100%);
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            border: 2px solid rgba(79, 172, 254, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
        }

        .token-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #4facfe, #00f2fe, #fa709a, #fee140);
        }

        .token-section h3 {
            color: #334155;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .token-section p {
            color: #64748b;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .token-display {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            margin: 10px 0;
            position: relative;
            max-height: 200px;
            overflow-y: auto;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #4facfe;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #4a5568;
        }

        .input-group input, .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus, .input-group textarea:focus {
            outline: none;
            border-color: #4facfe;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-success {
            background: #38a169;
            color: white;
        }

        .btn-danger {
            background: #e53e3e;
            color: white;
        }

        .btn-warning {
            background: #d69e2e;
            color: white;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
            text-align: center;
        }

        .status.connected {
            background: #c6f6d5;
            color: #22543d;
            border: 2px solid #38a169;
        }

        .status.connecting {
            background: #fefcbf;
            color: #744210;
            border: 2px solid #d69e2e;
        }

        .status.error {
            background: #fed7d7;
            color: #742a2a;
            border: 2px solid #e53e3e;
        }

        .workspace {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .workspace.active {
            display: block;
        }

        /* Document Editor Styles */
        .document-workspace {
            max-width: 1000px;
            margin: 0 auto;
        }

        .document-container {
            background: #f8fafc;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .document-title-section {
            margin-bottom: 30px;
        }

        .document-title-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            color: #2d3748;
            background: white;
            transition: all 0.3s ease;
        }

        .document-title-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .editor-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            padding: 15px 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 250, 252, 0.95) 100%);
            border-radius: 12px;
            flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .editor-btn {
            padding: 10px 12px;
            border: 1px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            color: #4a5568;
        }

        .editor-btn:hover {
            background: #f7fafc;
            border-color: #4facfe;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 172, 254, 0.15);
        }

        .editor-btn.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border-color: #4facfe;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 172, 254, 0.25);
        }

        .format-select {
            padding: 10px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            color: #4a5568;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .format-select:hover, .format-select:focus {
            border-color: #4facfe;
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: linear-gradient(to bottom, transparent, #e2e8f0, transparent);
            margin: 0 8px;
        }

        .a4-container {
            background: white;
            margin: 0 auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .a4-page {
            width: 21cm;
            min-height: 29.7cm;
            max-width: 100%;
            margin: 0 auto;
            background: white;
            position: relative;
        }

        @media screen and (max-width: 21cm) {
            .a4-page {
                width: 100%;
                min-height: calc(100vh - 400px);
            }
        }

        .editor {
            width: 100%;
            min-height: 29.7cm;
            border: none;
            padding: 2.5cm 2cm;
            font-family: 'Georgia', 'Times New Roman', serif;
            font-size: 16px;
            line-height: 1.6;
            color: #2d3748;
            background: white;
            resize: none;
            outline: none;
            box-sizing: border-box;
        }

        @media screen and (max-width: 21cm) {
            .editor {
                min-height: calc(100vh - 400px);
                padding: 40px 30px;
            }
        }

        .editor:focus {
            outline: none;
        }

        /* Page ruler/guidelines */
        .page-info {
            position: absolute;
            top: 10px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
        }

        /* Whiteboard Styles */
        .canvas-container {
            position: relative;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #whiteboard {
            display: block;
            cursor: crosshair;
        }

        .canvas-cursor {
            position: absolute;
            pointer-events: none;
            border: 2px solid #4facfe;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: none;
        }

        .canvas-tools {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: #f7fafc;
            border-radius: 8px;
        }

        .tool-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tool-group label {
            font-weight: bold;
            color: #4a5568;
            font-size: 14px;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            margin-top: 5px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-option:hover, .color-option.active {
            border-color: #4a5568;
            transform: scale(1.1);
        }

        .gradient-options {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .gradient-option {
            width: 40px;
            height: 25px;
            border-radius: 4px;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .gradient-option:hover, .gradient-option.active {
            border-color: #4a5568;
            transform: scale(1.05);
        }

        .size-display {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        .size-preview {
            background: #4a5568;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .tool-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .tool-btn {
            padding: 10px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            font-size: 14px;
        }

        .tool-btn:hover {
            border-color: #4facfe;
            background: #f0f9ff;
        }

        .tool-btn.active {
            background: #4facfe;
            color: white;
            border-color: #4facfe;
        }

        .download-section {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .hidden {
            display: none !important;
        }

        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            animation: slideIn 0.3s ease;
            max-width: 300px;
        }

        .alert-success {
            background: #38a169;
        }

        .alert-error {
            background: #e53e3e;
        }

        .alert-warning {
            background: #d69e2e;
        }

        .alert-info {
            background: #3182ce;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: inline-block;
            padding: 10px 20px;
            background: #38a169;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .file-label:hover {
            background: #2f855a;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
            }
            
            .mode-buttons, .role-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .editor-container {
                flex-direction: column;
                height: auto;
            }
            
            .editor {
                height: 300px;
            }
            
            .canvas-tools {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ WebRTC Collaborative Platform</h1>
            <button class="disconnect-btn" id="disconnectBtn" onclick="disconnect()">üîå Disconnect</button>
        </div>

        <div class="mode-selection">
            <div class="mode-buttons">
                <button class="mode-btn active" onclick="setMode('document')">üìù Document Editor</button>
                <button class="mode-btn" onclick="setMode('whiteboard')">üé® Whiteboard</button>
            </div>
        </div>

        <div class="connection-panel" id="connectionPanel">
            <div class="role-buttons">
                <button class="role-btn active" onclick="setRole('host')">üè† Host Room</button>
                <button class="role-btn" onclick="setRole('guest')">üîó Join Room</button>
            </div>

            <div id="hostPanel">
                <div class="token-section">
                    <h3>üîë Room Token</h3>
                    <p>Share this token with collaborators:</p>
                    <div class="token-display" id="tokenDisplay">
                        Click "Create Room" to generate token
                    </div>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-primary" onclick="createRoom()">üöÄ Create Room</button>
                        <button class="btn btn-success" onclick="downloadToken()">üíæ Download Token</button>
                    </div>
                </div>
            </div>

            <div id="guestPanel" class="hidden">
                <div class="token-section">
                    <h3>üîó Join Room</h3>
                    <div class="input-group">
                        <label>Enter Room Token:</label>
                        <textarea id="tokenInput" rows="4" placeholder="Paste the room token here..."></textarea>
                    </div>
                    <div style="margin: 15px 0;">
                        <span>Or upload token file: </span>
                        <input type="file" id="tokenFile" class="file-input" accept=".json" onchange="loadTokenFile()">
                        <label for="tokenFile" class="file-label">üìÅ Choose File</label>
                    </div>
                    <button class="btn btn-primary" onclick="joinRoom()">üöÄ Join Room</button>
                </div>
            </div>

            <div id="connectionStatus"></div>
            <div id="answerSection" class="hidden"></div>
        </div>

        <!-- Document Editor Workspace -->
        <div id="documentWorkspace" class="workspace active">
            <h2>üìù Document Editor</h2>
            <div class="input-group">
                <label>Document Title:</label>
                <input type="text" id="documentTitle" placeholder="Enter document title..." value="Untitled Document">
            </div>
            
            <div class="editor-toolbar">
                <button class="editor-btn" onclick="formatText('bold')" title="Bold"><b>B</b></button>
                <button class="editor-btn" onclick="formatText('italic')" title="Italic"><i>I</i></button>
                <button class="editor-btn" onclick="formatText('underline')" title="Underline"><u>U</u></button>
                <div style="border-left: 1px solid #cbd5e0; height: 20px; margin: 0 5px;"></div>
                <select class="format-select" onchange="formatText('fontSize', this.value)">
                    <option value="14px">14px</option>
                    <option value="16px" selected>16px</option>
                    <option value="18px">18px</option>
                    <option value="20px">20px</option>
                    <option value="24px">24px</option>
                </select>
                <select class="format-select" onchange="formatText('fontFamily', this.value)">
                    <option value="Georgia">Georgia</option>
                    <option value="Arial">Arial</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                </select>
                <div style="border-left: 1px solid #cbd5e0; height: 20px; margin: 0 5px;"></div>
                <button class="editor-btn" onclick="formatText('justifyLeft')" title="Align Left">‚¨Ö</button>
                <button class="editor-btn" onclick="formatText('justifyCenter')" title="Center">‚¨õ</button>
                <button class="editor-btn" onclick="formatText('justifyRight')" title="Align Right">‚û°</button>
                <div style="border-left: 1px solid #cbd5e0; height: 20px; margin: 0 5px;"></div>
                <button class="editor-btn" onclick="formatText('insertUnorderedList')" title="Bullet List">‚Ä¢ List</button>
                <button class="editor-btn" onclick="formatText('insertOrderedList')" title="Number List">1. List</button>
            </div>
            
            <div class="editor-container">
                <div id="documentEditor" class="editor" contenteditable="true" style="overflow-y: auto;"></div>
            </div>
            <div class="download-section">
                <button class="btn btn-success" onclick="saveDocument()">üíæ Save Document</button>
                <button class="btn btn-primary" onclick="downloadDocument()">üì• Download Document</button>
                <button class="btn btn-warning" onclick="loadDocument()">üìÅ Load Document</button>
                <input type="file" id="docFile" class="file-input" accept=".txt,.html" onchange="handleDocumentFile()">
            </div>
        </div>

        <!-- Whiteboard Workspace -->
        <div id="whiteboardWorkspace" class="workspace">
            <h2>üé® Whiteboard</h2>
            
            <div class="canvas-tools">
                <div class="tool-group">
                    <label>üé® Colors</label>
                    <div class="color-palette" id="colorPalette"></div>
                    <input type="color" id="customColor" style="width: 100%; height: 35px; margin-top: 5px;">
                </div>
                
                <div class="tool-group">
                    <label>üåà Gradients</label>
                    <div class="gradient-options" id="gradientOptions"></div>
                </div>
                
                <div class="tool-group">
                    <label>üìè Brush Size</label>
                    <input type="range" id="brushSize" min="1" max="50" value="5">
                    <div class="size-display">
                        <div class="size-preview" id="sizePreview"></div>
                        <span id="sizeText">5px</span>
                    </div>
                </div>
                
                <div class="tool-group">
                    <label>üîß Tools</label>
                    <div class="tool-buttons">
                        <button class="tool-btn active" onclick="setTool('brush')" data-tool="brush">üñåÔ∏è Brush</button>
                        <button class="tool-btn" onclick="setTool('eraser')" data-tool="eraser">üßΩ Eraser</button>
                        <button class="tool-btn" onclick="setTool('line')" data-tool="line">üìè Line</button>
                        <button class="tool-btn" onclick="setTool('rectangle')" data-tool="rectangle">‚ñ≠ Rectangle</button>
                        <button class="tool-btn" onclick="setTool('circle')" data-tool="circle">‚≠ï Circle</button>
                        <button class="tool-btn" onclick="setTool('triangle')" data-tool="triangle">üî∫ Triangle</button>
                        <button class="tool-btn" onclick="setTool('arrow')" data-tool="arrow">‚û§ Arrow</button>
                        <button class="tool-btn" onclick="setTool('star')" data-tool="star">‚≠ê Star</button>
                    </div>
                </div>
                
                <div class="tool-group">
                    <label>‚öôÔ∏è Actions</label>
                    <div class="tool-buttons">
                        <button class="btn btn-danger" onclick="clearCanvas()">üóëÔ∏è Clear</button>
                        <button class="btn btn-warning" onclick="undoCanvas()">‚Ü∂ Undo</button>
                        <button class="btn btn-info" onclick="redoCanvas()">‚Ü∑ Redo</button>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container" onmousemove="updateCursor(event)">
                <canvas id="whiteboard" width="1200" height="600"></canvas>
                <div class="canvas-cursor" id="canvasCursor"></div>
            </div>
            
            <div class="download-section">
                <button class="btn btn-success" onclick="saveCanvas()">üíæ Save Canvas</button>
                <button class="btn btn-primary" onclick="downloadCanvas()">üì• Download Canvas</button>
                <button class="btn btn-warning" onclick="loadCanvas()">üìÅ Load Canvas</button>
                <input type="file" id="canvasFile" class="file-input" accept="image/*,.json" onchange="handleCanvasFile()">
            </div>
        </div>
    </div>

    <script>
        // Security and utility functions
        function sanitizeInput(input) {
            if (typeof input !== 'string') return '';
            return input.replace(/[<>'"&]/g, function(match) {
                const entities = {
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#x27;',
                    '&': '&amp;'
                };
                return entities[match];
            });
        }

        function validateJSON(str) {
            try {
                const parsed = JSON.parse(str);
                if (parsed && typeof parsed === 'object') {
                    return parsed;
                }
            } catch (e) {
                return null;
            }
            return null;
        }

        function showAlert(message, type = 'info') {
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = sanitizeInput(message);
            document.body.appendChild(alert);
            
            setTimeout(() => {
                alert.remove();
            }, 4000);
        }

        function generateSecureId() {
            const array = new Uint32Array(8);
            crypto.getRandomValues(array);
            return Array.from(array, dec => dec.toString(16)).join('');
        }

        // Global variables
        let currentMode = 'document';
        let currentRole = 'host';
        let peerConnection = null;
        let dataChannel = null;
        let isConnected = false;
        let isHost = true;
        let roomToken = null;
        let canvas = null;
        let ctx = null;
        let isDrawing = false;
        let startX = 0;
        let startY = 0;
        let currentTool = 'brush';
        let currentColor = '#000000';
        let currentGradient = null;
        let brushSize = 5;
        let canvasHistory = [];
        let historyIndex = -1;
        let pendingAnswer = null;

        // WebRTC Configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        // Initialize the application
        function init() {
            setupEventListeners();
            setupCanvas();
            setupColorPalette();
            setupGradients();
            loadFromStorage();
            updateSizePreview();
        }

        function setupEventListeners() {
            const documentEditor = document.getElementById('documentEditor');
            const brushSizeSlider = document.getElementById('brushSize');

            documentEditor.addEventListener('input', function() {
                if (isConnected && dataChannel && dataChannel.readyState === 'open') {
                    sendMessage({
                        type: 'document-update',
                        content: this.innerHTML,
                        title: document.getElementById('documentTitle').value
                    });
                }
                saveToStorage();
            });

            document.getElementById('documentTitle').addEventListener('input', function() {
                if (isConnected && dataChannel && dataChannel.readyState === 'open') {
                    sendMessage({
                        type: 'document-update',
                        content: documentEditor.innerHTML,
                        title: this.value
                    });
                }
                saveToStorage();
            });

            brushSizeSlider.addEventListener('input', function() {
                brushSize = parseInt(this.value);
                updateSizePreview();
            });

            document.getElementById('customColor').addEventListener('change', function() {
                currentColor = this.value;
                currentGradient = null;
                updateColorSelection();
            });
        }

        function setupCanvas() {
            canvas = document.getElementById('whiteboard');
            ctx = canvas.getContext('2d');
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('mouseleave', function() {
                document.getElementById('canvasCursor').style.display = 'none';
            });

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);

            // Save initial state
            saveCanvasState();
        }

        function setupColorPalette() {
            const colors = [
                '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                '#800000', '#008000', '#000080', '#808000', '#800080', '#008080', '#C0C0C0', '#808080',
                '#FF9999', '#99FF99', '#9999FF', '#FFFF99', '#FF99FF', '#99FFFF', '#FFB366', '#B366FF'
            ];
            
            const palette = document.getElementById('colorPalette');
            colors.forEach(color => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'color-option';
                colorDiv.style.backgroundColor = color;
                colorDiv.onclick = () => selectColor(color);
                palette.appendChild(colorDiv);
            });
        }

        function setupGradients() {
            const gradients = [
                'linear-gradient(45deg, #ff0000, #ffff00)',
                'linear-gradient(45deg, #00ff00, #0000ff)',
                'linear-gradient(45deg, #ff00ff, #00ffff)',
                'linear-gradient(45deg, #ff8000, #ff0080)',
                'linear-gradient(90deg, #ff0000, #00ff00, #0000ff)',
                'radial-gradient(circle, #ff0000, #ffff00)'
            ];
            
            const gradientContainer = document.getElementById('gradientOptions');
            gradients.forEach(gradient => {
                const gradientDiv = document.createElement('div');
                gradientDiv.className = 'gradient-option';
                gradientDiv.style.background = gradient;
                gradientDiv.onclick = () => selectGradient(gradient);
                gradientContainer.appendChild(gradientDiv);
            });
        }

        function selectColor(color) {
            currentColor = color;
            currentGradient = null;
            updateColorSelection();
        }

        function selectGradient(gradient) {
            currentGradient = gradient;
            updateColorSelection();
        }

        function updateColorSelection() {
            document.querySelectorAll('.color-option').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.gradient-option').forEach(el => el.classList.remove('active'));
            
            if (currentGradient) {
                document.querySelectorAll('.gradient-option').forEach(el => {
                    if (el.style.background === currentGradient) {
                        el.classList.add('active');
                    }
                });
            } else {
                document.querySelectorAll('.color-option').forEach(el => {
                    if (el.style.backgroundColor === currentColor || 
                        el.style.backgroundColor === rgbToHex(currentColor)) {
                        el.classList.add('active');
                    }
                });
            }
        }

        function rgbToHex(rgb) {
            if (rgb.startsWith('#')) return rgb;
            const result = rgb.match(/\d+/g);
            if (!result) return rgb;
            return '#' + result.map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
        }

        function updateSizePreview() {
            const preview = document.getElementById('sizePreview');
            const text = document.getElementById('sizeText');
            preview.style.width = brushSize + 'px';
            preview.style.height = brushSize + 'px';
            text.textContent = brushSize + 'px';
        }

        function updateCursor(event) {
            const cursor = document.getElementById('canvasCursor');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            cursor.style.left = (event.clientX - rect.left) + 'px';
            cursor.style.top = (event.clientY - rect.top) + 'px';
            cursor.style.width = brushSize + 'px';
            cursor.style.height = brushSize + 'px';
            cursor.style.display = 'block';
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            const cursor = document.getElementById('canvasCursor');
            cursor.style.borderColor = tool === 'eraser' ? '#ff0000' : '#4facfe';
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            if (e.type === 'touchstart') {
                startDrawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchmove') {
                draw({ offsetX: x, offsetY: y });
            }
        }

        function setMode(mode) {
            currentMode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            document.querySelectorAll('.workspace').forEach(ws => ws.classList.remove('active'));
            document.getElementById(mode + 'Workspace').classList.add('active');
            
            showAlert(`Switched to ${mode} mode`, 'info');
        }

        function setRole(role) {
            currentRole = role;
            isHost = role === 'host';
            
            document.querySelectorAll('.role-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            document.getElementById('hostPanel').classList.toggle('hidden', !isHost);
            document.getElementById('guestPanel').classList.toggle('hidden', isHost);
            
            if (!isHost) {
                closeConnection();
            }
        }

        async function createRoom() {
            try {
                roomToken = {
                    id: generateSecureId(),
                    timestamp: Date.now(),
                    mode: currentMode
                };

                peerConnection = new RTCPeerConnection(rtcConfig);
                setupPeerConnection();

                dataChannel = peerConnection.createDataChannel('collaboration', {
                    ordered: true
                });
                setupDataChannel(dataChannel);

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                roomToken.offer = offer;
                
                const tokenText = JSON.stringify(roomToken, null, 2);
                document.getElementById('tokenDisplay').innerHTML = `<pre>${tokenText}</pre>`;

                updateConnectionStatus('Waiting for connection...', 'connecting');
                showAlert('Room created successfully! Share the token with collaborators.', 'success');
                
            } catch (error) {
                console.error('Error creating room:', error);
                showAlert('Failed to create room. Please try again.', 'error');
            }
        }

        async function joinRoom() {
            const tokenInput = document.getElementById('tokenInput').value.trim();
            
            if (!tokenInput) {
                showAlert('Please enter a room token.', 'warning');
                return;
            }

            const token = validateJSON(tokenInput);
            if (!token || !token.offer) {
                showAlert('Invalid token format.', 'error');
                return;
            }

            try {
                peerConnection = new RTCPeerConnection(rtcConfig);
                setupPeerConnection();

                peerConnection.ondatachannel = function(event) {
                    const channel = event.channel;
                    setupDataChannel(channel);
                    dataChannel = channel;
                };

                await peerConnection.setRemoteDescription(new RTCSessionDescription(token.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                const answerToken = {
                    id: token.id,
                    answer: answer,
                    timestamp: Date.now()
                };

                pendingAnswer = answerToken;
                
                updateConnectionStatus('Send this answer token to the host:', 'connecting');
                
                const answerSection = document.getElementById('answerSection');
                answerSection.classList.remove('hidden');
                answerSection.innerHTML = `
                    <div class="token-section">
                        <h3>üì§ Send This Answer to Host</h3>
                        <div class="token-display">
                            <pre>${JSON.stringify(answerToken, null, 2)}</pre>
                            <button class="copy-btn" onclick="copyAnswerToken()">üìã Copy</button>
                        </div>
                        <button class="btn btn-success" onclick="downloadAnswer()">üíæ Download Answer</button>
                    </div>
                `;

                showAlert('Answer generated! Send it to the host to complete connection.', 'info');

            } catch (error) {
                console.error('Error joining room:', error);
                showAlert('Failed to join room. Please check the token and try again.', 'error');
            }
        }

        function copyAnswerToken() {
            if (pendingAnswer) {
                const tokenText = JSON.stringify(pendingAnswer, null, 2);
                navigator.clipboard.writeText(tokenText).then(() => {
                    showAlert('Answer token copied to clipboard!', 'success');
                }).catch(() => {
                    showAlert('Failed to copy answer token.', 'error');
                });
            }
        }

        function downloadAnswer() {
            if (!pendingAnswer) {
                showAlert('No answer token to download.', 'warning');
                return;
            }

            const blob = new Blob([JSON.stringify(pendingAnswer, null, 2)], {
                type: 'application/json'
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `answer-token-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showAlert('Answer token downloaded!', 'success');
        }

        function setupPeerConnection() {
            peerConnection.oniceconnectionstatechange = function() {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
                
                if (peerConnection.iceConnectionState === 'connected' || 
                    peerConnection.iceConnectionState === 'completed') {
                    isConnected = true;
                    updateConnectionStatus('üü¢ Connected successfully!', 'connected');
                    hideConnectionPanel();
                    showAlert('Peer connection established!', 'success');
                } else if (peerConnection.iceConnectionState === 'disconnected' || 
                          peerConnection.iceConnectionState === 'failed') {
                    isConnected = false;
                    updateConnectionStatus('‚ùå Connection lost', 'error');
                    showConnectionPanel();
                    showAlert('Connection lost. Please try reconnecting.', 'error');
                }
            };

            // For host: handle incoming answer
            if (isHost) {
                const originalCreateDataChannel = peerConnection.createDataChannel;
                peerConnection.createDataChannel = function() {
                    const channel = originalCreateDataChannel.apply(this, arguments);
                    
                    // Add answer input field for host
                    setTimeout(() => {
                        if (!isConnected) {
                            const statusDiv = document.getElementById('connectionStatus');
                            if (!document.getElementById('hostAnswerInput')) {
                                statusDiv.innerHTML += `
                                    <div class="token-section" style="margin-top: 20px;">
                                        <h3>üì• Receive Guest Answer</h3>
                                        <textarea id="hostAnswerInput" rows="4" placeholder="Paste the guest answer token here..."></textarea>
                                        <br><br>
                                        <input type="file" id="answerFile" class="file-input" accept=".json" onchange="loadAnswerFile()">
                                        <label for="answerFile" class="file-label">üìÅ Load Answer File</label>
                                        <button class="btn btn-primary" onclick="processGuestAnswer()">üîó Complete Connection</button>
                                    </div>
                                `;
                            }
                        }
                    }, 1000);
                    
                    return channel;
                };
            }
        }

        function loadAnswerFile() {
            const file = document.getElementById('answerFile').files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const answer = validateJSON(e.target.result);
                    if (answer) {
                        document.getElementById('hostAnswerInput').value = JSON.stringify(answer, null, 2);
                        showAlert('Answer file loaded successfully!', 'success');
                    } else {
                        showAlert('Invalid answer file format.', 'error');
                    }
                } catch (error) {
                    showAlert('Error reading answer file.', 'error');
                }
            };
            reader.readAsText(file);
        }

        async function processGuestAnswer() {
            const answerText = document.getElementById('hostAnswerInput').value.trim();
            
            if (!answerText) {
                showAlert('Please enter the guest answer.', 'warning');
                return;
            }

            const answerData = validateJSON(answerText);
            if (!answerData || !answerData.answer) {
                showAlert('Invalid answer format.', 'error');
                return;
            }

            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answerData.answer));
                showAlert('Processing connection...', 'info');
            } catch (error) {
                console.error('Error processing guest answer:', error);
                showAlert('Failed to establish connection. Please check the answer token.', 'error');
            }
        }

        function setupDataChannel(channel) {
            channel.onopen = function() {
                console.log('Data channel opened');
                isConnected = true;
                updateConnectionStatus('üü¢ Data channel connected!', 'connected');
                hideConnectionPanel();
                
                if (isHost) {
                    sendCurrentContent();
                }
                
                showAlert('Ready to collaborate!', 'success');
            };

            channel.onclose = function() {
                console.log('Data channel closed');
                isConnected = false;
                updateConnectionStatus('‚ùå Data channel closed', 'error');
                showConnectionPanel();
            };

            channel.onmessage = function(event) {
                try {
                    handleMessage(JSON.parse(event.data));
                } catch (error) {
                    console.error('Error handling message:', error);
                }
            };

            channel.onerror = function(error) {
                console.error('Data channel error:', error);
                showAlert('Data channel error occurred.', 'error');
            };
        }

        function sendMessage(message) {
            if (dataChannel && dataChannel.readyState === 'open') {
                try {
                    dataChannel.send(JSON.stringify(message));
                } catch (error) {
                    console.error('Error sending message:', error);
                }
            }
        }

        function sendCurrentContent() {
            if (currentMode === 'document') {
                sendMessage({
                    type: 'document-update',
                    content: document.getElementById('documentEditor').innerHTML,
                    title: document.getElementById('documentTitle').value
                });
            } else if (currentMode === 'whiteboard') {
                sendMessage({
                    type: 'canvas-data',
                    imageData: canvas.toDataURL()
                });
            }
        }

        function handleMessage(message) {
            switch (message.type) {
                case 'document-update':
                    if (currentMode === 'document') {
                        document.getElementById('documentEditor').innerHTML = message.content;
                        document.getElementById('documentTitle').value = sanitizeInput(message.title);
                        saveToStorage();
                    }
                    break;
                    
                case 'canvas-draw':
                    if (currentMode === 'whiteboard') {
                        drawRemotePath(message);
                    }
                    break;
                    
                case 'canvas-data':
                    if (currentMode === 'whiteboard') {
                        loadCanvasFromDataURL(message.imageData);
                    }
                    break;
                    
                case 'canvas-clear':
                    if (currentMode === 'whiteboard') {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        saveCanvasState();
                        saveToStorage();
                    }
                    break;
            }
        }

        function hideConnectionPanel() {
            document.getElementById('connectionPanel').style.display = 'none';
            document.getElementById('disconnectBtn').style.display = 'block';
        }

        function showConnectionPanel() {
            document.getElementById('connectionPanel').style.display = 'block';
            document.getElementById('disconnectBtn').style.display = 'none';
        }

        function disconnect() {
            closeConnection();
            showConnectionPanel();
            showAlert('Disconnected from collaboration session.', 'info');
        }

        function copyToken() {
            const tokenDisplay = document.getElementById('tokenDisplay');
            const tokenText = tokenDisplay.textContent.trim();
            
            navigator.clipboard.writeText(tokenText).then(() => {
                showAlert('Token copied to clipboard!', 'success');
            }).catch(() => {
                showAlert('Failed to copy token.', 'error');
            });
        }

        function downloadToken() {
            if (!roomToken) {
                showAlert('No token to download. Create a room first.', 'warning');
                return;
            }

            const blob = new Blob([JSON.stringify(roomToken, null, 2)], {
                type: 'application/json'
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `room-token-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showAlert('Token file downloaded!', 'success');
        }

        function loadTokenFile() {
            const file = document.getElementById('tokenFile').files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const token = validateJSON(e.target.result);
                    if (token) {
                        document.getElementById('tokenInput').value = JSON.stringify(token, null, 2);
                        showAlert('Token file loaded successfully!', 'success');
                    } else {
                        showAlert('Invalid token file format.', 'error');
                    }
                } catch (error) {
                    showAlert('Error reading token file.', 'error');
                }
            };
            reader.readAsText(file);
        }

        function updateConnectionStatus(message, type) {
            const statusDiv = document.getElementById('connectionStatus');
            if (message) {
                statusDiv.innerHTML = `<div class="status ${type}">${sanitizeInput(message)}</div>`;
            } else {
                statusDiv.innerHTML = '';
            }
        }

        function closeConnection() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            isConnected = false;
            pendingAnswer = null;
            updateConnectionStatus('', '');
            document.getElementById('answerSection').classList.add('hidden');
        }

        // Document Editor Functions
        function formatText(command, value = null) {
            document.execCommand(command, false, value);
            document.getElementById('documentEditor').focus();
            
            // Send update to peer
            if (isConnected && dataChannel && dataChannel.readyState === 'open') {
                sendMessage({
                    type: 'document-update',
                    content: document.getElementById('documentEditor').innerHTML,
                    title: document.getElementById('documentTitle').value
                });
            }
            saveToStorage();
        }

        // Drawing functions
        function startDrawing(e) {
            isDrawing = true;
            startX = e.offsetX;
            startY = e.offsetY;
            
            if (currentTool === 'brush' || currentTool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            }
            
            saveCanvasState();
        }

        function draw(e) {
            if (!isDrawing) return;
            
            const endX = e.offsetX;
            const endY = e.offsetY;
            
            if (currentTool === 'brush' || currentTool === 'eraser') {
                drawBrushStroke(endX, endY);
                
                if (isConnected) {
                    sendMessage({
                        type: 'canvas-draw',
                        tool: currentTool,
                        color: currentColor,
                        gradient: currentGradient,
                        size: brushSize,
                        x: endX,
                        y: endY,
                        startX: startX,
                        startY: startY,
                        drawing: true
                    });
                }
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            
            const endX = e.offsetX;
            const endY = e.offsetY;
            
            if (currentTool !== 'brush' && currentTool !== 'eraser') {
                drawShape(startX, startY, endX, endY);
                
                if (isConnected) {
                    sendMessage({
                        type: 'canvas-draw',
                        tool: currentTool,
                        color: currentColor,
                        gradient: currentGradient,
                        size: brushSize,
                        x: endX,
                        y: endY,
                        startX: startX,
                        startY: startY,
                        drawing: false
                    });
                }
            }
            
            saveCanvasState();
            saveToStorage();
        }

        function drawBrushStroke(x, y) {
            ctx.lineWidth = brushSize;
            ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
            
            if (currentGradient && currentTool !== 'eraser') {
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                applyGradient(gradient, currentGradient);
                ctx.strokeStyle = gradient;
            } else {
                ctx.strokeStyle = currentTool === 'eraser' ? '#FFFFFF' : currentColor;
            }
            
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        function drawShape(x1, y1, x2, y2) {
            ctx.lineWidth = brushSize;
            ctx.globalCompositeOperation = 'source-over';
            
            if (currentGradient) {
                const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                applyGradient(gradient, currentGradient);
                ctx.strokeStyle = gradient;
            } else {
                ctx.strokeStyle = currentColor;
            }
            
            ctx.beginPath();
            
            switch (currentTool) {
                case 'line':
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    break;
                case 'rectangle':
                    ctx.rect(x1, y1, x2 - x1, y2 - y1);
                    break;
                case 'circle':
                    const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
                    break;
                case 'triangle':
                    const midX = (x1 + x2) / 2;
                    ctx.moveTo(midX, y1);
                    ctx.lineTo(x1, y2);
                    ctx.lineTo(x2, y2);
                    ctx.closePath();
                    break;
                case 'arrow':
                    drawArrow(x1, y1, x2, y2);
                    break;
                case 'star':
                    drawStar(x1, y1, Math.abs(x2 - x1));
                    break;
            }
            
            ctx.stroke();
        }

        function drawArrow(x1, y1, x2, y2) {
            const headLength = 20;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            
            ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6),
                      y2 - headLength * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6),
                      y2 - headLength * Math.sin(angle + Math.PI / 6));
        }

        function drawStar(centerX, centerY, radius) {
            const spikes = 5;
            const outerRadius = radius;
            const innerRadius = radius * 0.4;
            
            let rot = Math.PI / 2 * 3;
            let x = centerX;
            let y = centerY;
            const step = Math.PI / spikes;
            
            ctx.moveTo(centerX, centerY - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = centerX + Math.cos(rot) * outerRadius;
                y = centerY + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;
                
                x = centerX + Math.cos(rot) * innerRadius;
                y = centerY + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(centerX, centerY - outerRadius);
            ctx.closePath();
        }

        function applyGradient(gradient, gradientString) {
            if (gradientString.includes('linear-gradient')) {
                const colors = gradientString.match(/#[0-9a-fA-F]{6}/g) || 
                             gradientString.match(/rgb\([^)]+\)/g) || 
                             ['#ff0000', '#ffff00'];
                colors.forEach((color, index) => {
                    gradient.addColorStop(index / (colors.length - 1), color);
                });
            }
        }

        function drawRemotePath(data) {
            if (data.drawing && (data.tool === 'brush' || data.tool === 'eraser')) {
                ctx.lineWidth = data.size;
                ctx.globalCompositeOperation = data.tool === 'eraser' ? 'destination-out' : 'source-over';
                
                if (data.gradient && data.tool !== 'eraser') {
                    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    applyGradient(gradient, data.gradient);
                    ctx.strokeStyle = gradient;
                } else {
                    ctx.strokeStyle = data.tool === 'eraser' ? '#FFFFFF' : data.color;
                }
                
                ctx.lineTo(data.x, data.y);
                ctx.stroke();
            } else if (!data.drawing) {
                ctx.lineWidth = data.size;
                ctx.globalCompositeOperation = 'source-over';
                
                if (data.gradient) {
                    const gradient = ctx.createLinearGradient(data.startX, data.startY, data.x, data.y);
                    applyGradient(gradient, data.gradient);
                    ctx.strokeStyle = gradient;
                } else {
                    ctx.strokeStyle = data.color;
                }
                
                drawShape(data.startX, data.startY, data.x, data.y);
            }
            
            saveCanvasState();
            saveToStorage();
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (isConnected) {
                sendMessage({ type: 'canvas-clear' });
            }
            
            saveCanvasState();
            saveToStorage();
            showAlert('Canvas cleared!', 'info');
        }

        function saveCanvasState() {
            historyIndex++;
            if (historyIndex < canvasHistory.length) {
                canvasHistory.length = historyIndex;
            }
            canvasHistory.push(canvas.toDataURL());
            
            if (canvasHistory.length > 50) {
                canvasHistory.shift();
                historyIndex--;
            }
        }

        function undoCanvas() {
            if (historyIndex > 0) {
                historyIndex--;
                loadCanvasFromDataURL(canvasHistory[historyIndex]);
                showAlert('Undo applied', 'info');
            }
        }

        function redoCanvas() {
            if (historyIndex < canvasHistory.length - 1) {
                historyIndex++;
                loadCanvasFromDataURL(canvasHistory[historyIndex]);
                showAlert('Redo applied', 'info');
            }
        }

        function loadCanvasFromDataURL(dataURL) {
            const img = new Image();
            img.onload = function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                saveToStorage();
            };
            img.src = dataURL;
        }

        // Storage functions
        function saveToStorage() {
            try {
                const data = {
                    document: {
                        title: document.getElementById('documentTitle').value,
                        content: document.getElementById('documentEditor').innerHTML
                    },
                    canvas: canvas ? canvas.toDataURL() : null,
                    timestamp: Date.now()
                };
                
                window.collaborationData = data;
            } catch (error) {
                console.error('Error saving to storage:', error);
            }
        }

        function loadFromStorage() {
            try {
                const data = window.collaborationData;
                
                if (data) {
                    if (data.document) {
                        document.getElementById('documentTitle').value = data.document.title || '';
                        document.getElementById('documentEditor').innerHTML = data.document.content || '';
                    }
                    
                    if (data.canvas && canvas) {
                        loadCanvasFromDataURL(data.canvas);
                    }
                }
            } catch (error) {
                console.error('Error loading from storage:', error);
            }
        }

        // Document functions
        function saveDocument() {
            try {
                const data = {
                    title: document.getElementById('documentTitle').value,
                    content: document.getElementById('documentEditor').innerHTML,
                    timestamp: Date.now(),
                    type: 'document'
                };
                
                window.collaborationData = { ...window.collaborationData, document: data };
                showAlert('Document saved successfully!', 'success');
            } catch (error) {
                showAlert('Failed to save document.', 'error');
            }
        }

        function downloadDocument() {
            const title = document.getElementById('documentTitle').value || 'Untitled Document';
            const content = document.getElementById('documentEditor').innerHTML;
            
            const htmlContent = `<!DOCTYPE html><html><head><title>${sanitizeInput(title)}</title></head><body>${content}</body></html>`;
            
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${sanitizeInput(title)}.html`;
            a.click();
            URL.revokeObjectURL(url);
            
            showAlert('Document downloaded!', 'success');
        }

        function loadDocument() {
            document.getElementById('docFile').click();
        }

        function handleDocumentFile() {
            const file = document.getElementById('docFile').files[0];
            if (!file) return;
            
            if (file.size > 10000000) {
                showAlert('File too large. Maximum size is 10MB.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let content = e.target.result;
                    let title = file.name.replace(/\.[^/.]+$/, "");
                    
                    if (file.name.endsWith('.html')) {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(content, 'text/html');
                        const titleElement = doc.querySelector('title');
                        const bodyElement = doc.querySelector('body');
                        
                        if (titleElement) title = titleElement.textContent;
                        if (bodyElement) content = bodyElement.innerHTML;
                    }
                    
                    document.getElementById('documentTitle').value = sanitizeInput(title);
                    document.getElementById('documentEditor').innerHTML = content;
                    
                    saveToStorage();
                    
                    if (isConnected) {
                        sendMessage({
                            type: 'document-update',
                            content: content,
                            title: title
                        });
                    }
                    
                    showAlert('Document loaded successfully!', 'success');
                } catch (error) {
                    showAlert('Error loading document file.', 'error');
                }
            };
            reader.readAsText(file);
        }

        // Canvas functions
        function saveCanvas() {
            try {
                const data = {
                    imageData: canvas.toDataURL(),
                    timestamp: Date.now(),
                    type: 'canvas'
                };
                
                window.collaborationData = { ...window.collaborationData, canvas: data.imageData };
                showAlert('Canvas saved successfully!', 'success');
            } catch (error) {
                showAlert('Failed to save canvas.', 'error');
            }
        }

        function downloadCanvas() {
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `whiteboard-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showAlert('Canvas downloaded!', 'success');
            });
        }

        function loadCanvas() {
            document.getElementById('canvasFile').click();
        }

        function handleCanvasFile() {
            const file = document.getElementById('canvasFile').files[0];
            if (!file) return;
            
            if (file.size > 20000000) {
                showAlert('File too large. Maximum size is 20MB.', 'error');
                return;
            }

            if (file.name.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = validateJSON(e.target.result);
                        if (data && data.imageData) {
                            loadCanvasFromDataURL(data.imageData);
                            showAlert('Canvas loaded successfully!', 'success');
                            
                            if (isConnected) {
                                sendMessage({
                                    type: 'canvas-data',
                                    imageData: data.imageData
                                });
                            }
                        } else {
                            showAlert('Invalid canvas file format.', 'error');
                        }
                    } catch (error) {
                        showAlert('Error loading canvas file.', 'error');
                    }
                };
                reader.readAsText(file);
            } else if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    loadCanvasFromDataURL(e.target.result);
                    showAlert('Image loaded to canvas!', 'success');
                    
                    if (isConnected) {
                        sendMessage({
                            type: 'canvas-data',
                            imageData: e.target.result
                        });
                    }
                };
                reader.readAsDataURL(file);
            } else {
                showAlert('Please select a valid image or JSON file.', 'error');
            }
        }

        // Initialize the application when the page loads
        window.addEventListener('load', init);

        // Handle page unload
        window.addEventListener('beforeunload', function() {
            if (peerConnection) {
                peerConnection.close();
            }
        });

        // Handle visibility change to save data
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'hidden') {
                saveToStorage();
            }
        });

        // Auto-save every 30 seconds
        setInterval(saveToStorage, 30000);
    </script>
</body>
</html>
